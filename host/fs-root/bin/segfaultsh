#! /bin/bash -r

# This is called by SSHD inside SF-HOST docker.
# - All environments have been cleared by SSHD.
# - Redirects not allowed in restricted shells.

# Load/restore environment variables from file
# `source' is prohibited in restricted bash shell (bash -r)
# use `eval' trick to load environemnt variables into a restricted shell
# SF_DEBUG can be set by ssh-client with -o SetEnv SF_DEBUG=1 or by
# docker compose '.env' file.
SSH_SF_DEBUG="${SF_DEBUG}" # Set by SSH client
[[ -f /dev/shm/env.txt ]] && eval "$(cat /dev/shm/env.txt)"
[[ -z $SF_DEBUG ]] && SF_DEBUG="${SSH_SF_DEBUG}"
unset SSH_SF_DEBUG

CY="\033[1;33m" # yellow
CR="\033[1;31m" # red
CC="\033[1;36m" # cyan
CG="\033[1;32m" # green
CDC="\033[0;36m" # cyan
CDR="\033[0;31m" # red
CN="\033[0m"    # none
CW="\033[1;37m" # white
CF="\033[2m"    # faint

ERREXIT()
{
	local code
	code="$1"
	[[ -z $code ]] && code=99

	shift 1
	[[ -n $1 ]] && echo -e >&2 "${CR}ERROR:${CN} $*"

	exit "$code"
}

if [[ -z $SF_DEBUG ]]; then
	DEBUGF(){ :;}
	SF_DOCKER_LOG="none"
else
	DEBUGF(){ echo -e 1>&2 "${CY}DEBUG:${CN} $*";}
	SF_DOCKER_LOG="local"
fi

# The current 'restricted shell' does not allow for stdout redirection to /dev/null.
# Thus execute in unrestricted shell with 'exec_devnull' and redirect stdout to /dev/null. 
exec_devnull()
{
	if [[ -z $SF_DEBUG ]]; then
		bash -c "exec $* 2>/dev/null >/dev/null"
	else
		# HERE: DEBUG is enabled. Show STDOUT/STDERR
		$*
	fi
}

exec_errnull()
{
	if [[ -z $SF_DEBUG ]]; then
		bash -c "exec $* 2>/dev/null"
	else
		# HERE: DEBUG is enabled. Show STDOUT/STDERR
		$*
	fi
}

# Overcoming a restricted shell. Write $1 to file in $2
# tofile "foobar \$HOME \"|';id;" world.txt
tofile()
{
	local str
	# Replace ' with '"'"'
	str="${1//\'/\'\"\'\"\'/}"
	bash -c "echo '$str'>'$2'"
}

print_disclaimer()
{
	echo 1>&2 -e "\
${CR}######################################################################
#### ${CY}DISCLAIMER: TO BE USED FOR CREATIVE AND GOOD PURPOSES ONLY..${CR} ####
#### ${CY}USE AT YOUR OWN RISK.     ---> DON'T FUCK UP <---            ${CR}####
######################################################################${CN}"
}

print_ssh_access()
{
	echo 1>&2 -e "\
:Cut & Paste these lines to your workstation's shell to retain access:
######################################################################
${CDC}cat >~/.ssh/id_ed25519-lg-${LID} ${CDR}<<__EOF__
${CN}${CF}$(cat ~/.ssh/id_ed25519)
${CDR}__EOF__
${CDC}cat >>~/.ssh/config ${CDR}<<${CDR}__EOF__
${CN}${CF}host ${SF_HOSTNAME,,}
    HostName ${SF_FQDN}
    IdentityFile ~/.ssh/id_ed25519-lg-${LID}
    SetEnv SECRET=${SF_SEC}
${CDR}__EOF__
${CDC}chmod 600 ~/.ssh/config ~/.ssh/id_ed25519-lg-${LID}${CN}
######################################################################
Thereafter use this command to connect to your server:
--> ${CDC}ssh root@${SF_HOSTNAME,,}${CN}
----------------------------------------------------------------------"
}

# Output GOODBYE message with infos how to connect back to this shell
print_goodbye()
{
	[[ -z $IS_PTY ]] && return

	# Restricted shell (-r) wont let us redirect stderr - use a bash-exec trick
	n="$(bash -c "docker exec \"lg-${LID}\" ps --no-headers aux 2>/dev/null|wc -l")"
	DEBUGF "Processes running: $n"
	if [[ "$n" -gt 4 ]]; then
		echo -e "\
${CY}WARNING: Another shell or background process is still running.${CN}
-------> The encrypted filesystem in /sec will remain mounted until
-------> the last shell exits or all background processes terminate.
-------> Type ${CC}halt${CN} instead to stop this instance. This will
-------> also make /sec unavailabe until your next login."
	fi
	echo -e "\
Access with      : ${CDC}ssh -o \"SetEnv SECRET=${SF_SEC:-UNKNOWN}\" ${SF_USER}@${SF_FQDN:-UNKNOWN}${CN}
GOODBYE          : ${CW}Join us on Telegram - https://t.me/thcorg${CN}"
}

echo_pty()
{
	[[ -n $IS_PTY ]] || return
	echo "$@"
}

spawn_shell_exit()
{
	# $@ is either ("-c", "<command>") or empty
	DEBUGF "ARG(${#})=$*"
	[[ ${#} -ne 0 ]] && [[ ${#} -ne 2 ]] && ERREXIT 127 "BAD ($*)"

	docker exec "$ARG" "lg-${LID}" zsh "${PARAM[@]}" "$@"
	ret="$?" # save return value and exit this script later with same return value.
	print_goodbye

	exit "$ret"
}

# Generate a mnemonic hostname from LID (e.g. ButterflyCat)
mk_hostname()
{
	NUM=$(echo "ibase=16; $(echo "$LID" | md5sum | cut -f1 -d" " | tr 'a-z' A-Z)" | bc)
	readarray -t english </etc/english.txt
	SF_HOSTNAME="UnknownUnknown"
	if [[ "${#english[@]}" -eq 2048 ]]; then
		SF_HOSTNAME="${english[$((NUM % 2048))]}"
		SF_HOSTNAME+="${english[$(( (NUM / 2048) % 2048 ))]}"
	fi
	DEBUGF "SF_HOSTNAME=$SF_HOSTNAME"
	unset NUM
	unset english
}

# Find out if SSHD allocated a TTY
# - Execute `tty' in unrestricted shell (one day a clever hacker will exploit this)
# - Set docker arguments to login-shell if this is a TTY session.
if bash -c "tty >/dev/null"; then
	ARG="-it"
	PARAM=("-il")
	IS_PTY=1
else
	ARG="-i"
	PARAM=();
fi

# Connect to existing session
if [[ -n $SECRET ]] && [[ ${#SECRET} -eq 24 ]] && [[ ! "${SECRET}" =~  [^a-zA-Z0-9] ]]; then
	IS_TRY_EXISTING=1
	SF_SEC="${SECRET}"
else
	SF_SEC="$(head -c 1024 /dev/urandom | tr -dc '[:alpha:]' | head -c 24)"
fi

LID=$(echo -n "LID ${SF_SEC}" | sha512sum | base64 | tr -dc '[:alpha:]' | head -c 10)

SF_VER="1.1"
MARKFILE="THIS-DIRECTORY-IS-NOT-ENCRYPTED--DO-NOT-USE.txt"

[[ -z $SF_SEED ]] && ERREXIT 244 "SF_SEED= is not set."

mk_hostname

if [[ -d "/config/db/db-${LID}" ]]; then
	echo_pty -n "Connecting to server. Please wait..."
else
	print_disclaimer
	echo_pty -n "Creating new server. Please wait...."

	# A hostname is generated from the LID. Avoid collision when a hostname
	# has already been created for a different LID.
	[[ -e "/config/db/hn2lid-${SF_HOSTNAME}" ]] && {
		lid_old=$(cat "/config/db/hn2lid-${SF_HOSTNAME}")
		[[ "$lid_old" -ne "$LID" ]] && {
			DEBUGF "$SF_HOSTNAME already used by ${lid_old} (this is ${LID})."
			ERREXIT 13 "Hostname Collision. Try again.."
		}
		unset lid_old
	}
	IS_NEW_SERVER=1

	mkdir -p "/config/db/db-${LID}" || ERREXIT
	touch "/config/db/db-${LID}/created.txt" || ERREXIT
	[[ -d /config/db/hn/ ]] || exec_devnull mkdir /config/db/hn
	tofile "$LID" "/config/db/hn/hn2lid-${SF_HOSTNAME}"
fi

DEBUGF "LID=${LID} SF_HOSTNAME=${SF_HOSTNAME}"

if [[ "$(exec_errnull docker container inspect "encfs-${LID}" -f '{{.State.Status}}')" != "running" ]]; then
	LENCFS_PASS=$(echo -n "EncFS-PASS-${SF_SEED}${SF_SEC}" | sha512sum | base64 | tr -dc '[:alpha:]' | head -c 24)
	# HERE: encfs is not already running for this instance...
	DEBUGF "EncFS-${LID} is not yet running..."

	# EncFS	to mount encrypted to mount-point.
	# Run in background (-d)
	# Use exec_devnull to redirect Container-ID to /dev/null (docker run -d).
	exec_devnull docker run \
		--rm \
		--name "encfs-${LID}" \
		--cap-add SYS_ADMIN \
		--device /dev/fuse \
		--security-opt apparmor:unconfined \
		--env LENCFS_PASS="${LENCFS_PASS}" \
		--env LID="${LID}" \
		--env SF_DEBUG="${SF_DEBUG}" \
		--log-driver "${SF_DOCKER_LOG}" \
		-v "${SF_BASEDIR}/data/user:/encfs/raw" \
		-v "${SF_SHMDIR}/encfs-sec:/encfs/sec:shared" \
		-v "/var/run/docker.sock:/var/run/docker.sock" \
		-d \
		sf-encfs || ERREXIT 251 "Could not create /sec..."
fi
echo_pty -n ".."

# Wait until sf-encf has mounted the secure drive...or otherwise this
# will show an insecure directory:
#    ssh user@segfault.thc.org "ls -al /sec"
# This will loop until the MARKFILE is gone (e.g. encfs mounted a directory over it)
# NOTE: It would be quicker to have /encfs/sec available in this sf-host instance
#       but this may also pose a security risk: A vulnerability in SSHD would
#       expose all encrypted drives. Doing it with 'docker run' means that
#       the hacker would to to break docker - which is easy enough given that the
#       docker-socket is available in this context but still a step harder.

DEBUGF "Waiting until /sec becomes available..."
docker exec \
	"encfs-${LID}" \
	/bin/sh -c \
	"LID=\"${LID}\" \
	SF_DEBUG=\"${SF_DEBUG}\" \
	MARKFILE=\"${MARKFILE}\" \
	/mount.sh" || ERREXIT 244 "Failed to set up /sec..."

echo_pty -n "...."


# Attach to instance if already running
[[ -n $IS_TRY_EXISTING ]] && {
	DEBUGF "Attaching to existing instance lg-${LID}..."
	exec_devnull docker container inspect "lg-${LID}" -f '{{.State.Status}}' && { 
		echo_pty -e "........................[${CG}OK${CN}]"
		spawn_shell_exit "$@"
		# NOT REACHED
	}
	echo_pty -n ".."

	DEBUGF "FAILED to attached to lg-${LID}"
	# HERE: Instance does not exists.
}

### Create ONION directory:
# This script runs under UID=1000 (root) and does not have write permission to
# /onion. Thus jump via docker.
[[ -d "/onion/${SF_HOSTNAME,,}" ]] || { 
	DEBUGF "Creating /onion/${SF_HOSTNAME,,}"
	exec_devnull docker exec sf-host mkdir "/onion/${SF_HOSTNAME,,}"
	DEBUGF "ret $?"
}

# Starting GUEST shell
# Challenge: Keep user processes running that got spawned in the background
# even when first instance terminates. Also do not terminate instance
# when there are still shells using it ('docker exec').
# Solution: Spawn a docker in the background that monitors the number of
# processes and use 'docker exec' for every connection.
exec_devnull docker run \
	--hostname "sf-${SF_HOSTNAME}" \
	--rm \
	--init \
	--name "lg-${LID}" \
	--init \
	--net sf_guest-net \
	--dns "${SF_DNS:-BAD}" \
	--env SF_SEC="${SF_SEC}" \
	--env SF_TOR="${SF_TOR}" \
	--env SF_VER="${SF_VER}" \
	--env SF_USER="${SF_USER}" \
	--env SF_FQDN="${SF_FQDN}" \
	--env SF_DEBUG="${SF_DEBUG}" \
	--env SF_HOSTNAME="${SF_HOSTNAME}" \
	-e SSH_CONNECTION \
	-e SSH_CLIENT \
	--log-driver "${SF_DOCKER_LOG}" \
	--mount type=bind,source="${SF_BASEDIR}/config/etc/ssh/id_ed25519,target=/config/id_ed25519,readonly" \
	--mount type=bind,source="${SF_BASEDIR}/config/${SF_FQDN:-this}/tor/hidden/service-22/hostname,target=/config/onion_hostname-22,readonly" \
	--mount type=bind,source="${SF_BASEDIR}/config/${SF_FQDN:-this}/tor/hidden/service-80/hostname,target=/config/onion_hostname-80,readonly" \
	--mount type=bind,source="${SF_SHMDIR}/run/vpn,target=/sf/run/vpn,readonly" \
	--mount type=bind,source="${SF_SHMDIR}/run/gsnc/access-22.txt,target=/sf/run/gsnc-access-22.txt,readonly" \
	-v "${SF_SHMDIR}/encfs-sec/user-${LID}:/sec:slave" \
	-v "${SF_SHMDIR}/encfs-sec/onion-www/${SF_HOSTNAME,,}:/onion:slave" \
	-d \
	sf-guest /sf/bin/sf-destructor.sh || ERREXIT 251 "Failed to set up guest instance..."

echo_pty -n ".."

DEBUGF "Instance started..."

# Wait for detached docker shell to become available...
n=0
while :; do
	str="$(exec_errnull docker container inspect "lg-${LID}" -f '{{.State.Status}}')"
	rc="$?"
	DEBUGF "rc=$rc status=$str"
	[[ "$rc" -eq 0 ]] && [[ "$str" = "running" ]] && break
	DEBUGF "#${n} Waiting for sf-guest to be ready..."
	if [[ $n -gt 0 ]]; then sleep 5; else sleep 0.1; fi
	n=$((n+1))
	[[ $n -gt 2 ]] && ERREXIT 253 "Could not create instance..."
done
echo_pty -n ".."

# Setup instance
docker exec "lg-${LID}" /sf/bin/sf-setup.sh || ERREXIT 252 "Failed to set up guest instance..."

echo_pty -e "....................[${CG}OK${CN}]"

# Output help of how to connect elegantly
[[ -n $IS_NEW_SERVER ]] && print_ssh_access

DEBUGF "Status: $(docker container inspect "lg-${LID}" -f '{{.State.Status}}')"
[[ -z $SF_DEBUG ]] || {
	docker exec "lg-${LID}" ls -ald /root /sec/root
}
# Spawn shell
spawn_shell_exit "$@"
# NOT REACHED

